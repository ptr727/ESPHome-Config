# Required substitutions:
# device_name
# device_comment

# Norvi NORVI-ENET-AE06-R
# https://shop.norvi.lk/products/norvi-enet-ae06-r
# https://norvi.lk/product/industrial-esp32-ethernet/
# https://norvi.lk/docs/norvi-enet-ae06-r-norvi-enet-ae06-r-user-guide/
# https://norvi.lk/docs/norvi-enet-ae06-r-datasheet/

# SensOper SC-EN-I6-RO4
# https://sensoper.com/shop/sc-en-i6-ro4/
# https://sensoper.com/wp-content/uploads/2021/09/SC-EN-Range-Datasheet.pdf

# IIOT Products SC-EN-I6-RO4
# https://iiotproducts.com/product/sc-en-i6-ro4/
# https://iiotproducts.com/wp-content/uploads/2021/11/SC-EN-I6-RO4_SC-EN-Range-Datasheet.pdf
# https://iiotproducts.com/wp-content/uploads/2022/07/SENSOPER-SC-EN-I6-TO4.zip
# https://iiotproducts.com/wp-content/uploads/2022/07/SC-EN-I6-R04_Test_Guide.docx.pdf

# Example code:
# https://norvi.lk/docs/
# https://www.instructables.com/Working-With-Built-in-Display-and-Push-Buttons-of-/
# https://github.com/Iconic-Devices/Norvi-IoT-Devices---ESP32-based-industrial-controllers
# https://github.com/philipptrenz/Norvi-Enet-Modbus

# ESP32-WROOM32
## ESP32 Dev Module
## Flash Mode QIO
## Flash Size 4MB
## Flash Frequency 10MHz
## PSRAM Disabled
## Upload Speed 115200

# ADC ADS1115
## I2C IO16(SDA) - IO17(SCL)
## Module Address 0x48
## Resolution 16 bit

# OLED SSD1306
## I2C IO16(SDA) - IO17(SCL)
## Module Address 0x3C
## Resolution 128 x 64

# Ethernet W5500
## SCLK IO18
## MISO IO19
## MOSI IO23
## SCSn IO26
## RSTn IO27
## IO5 CS of microSD should be High for the W5500

# RTC DS3231
## I2C IO16(SDA) - IO17(SCL)
## Module Address 0x68
## Reset IO21
## Battery Backup YES

# microSD Card
## SCK IO18
## MISO IO19
## MOSI IO23
## CS IO5
## SD Detect IO14

# Buttons
## ADC
## IO36
## Resistor network: 3.3V, S3 10K, S2 33K, S1 67K, 47K GND
## None  : 0
## Up    : 1.361V
## Down  : 1.939V
## Enter : 2.721V

# Expansion
## 1 Not Connected
## 2 TXD0
## 3 5V
## 4 RXD0
## 5 BOOT IO0
## 6 IO15
## 7 3.3V
## 8 SCL IO17
## 9 Ground
## 10 SDA IO16

# Relay Output
## R0 IO2
## R1 IO4
## R2 IO12
## R3 IO13

# Source/Sink Input
## I0 IO21
## I1 IO14
## I2 IO33
## I3 IO34
## I4 IO35
## I5 IO25
## I6 IO32
## I7 IO22

# Observations on my April 2023 SensOper SC-EN-I6-RO4 and December 2023 Norvi IIOT-AE06-R:
##
## April 2023: the Norvi online store shop.norvi.lk did not ship to the US, Norvi referred me to buy the SensOper branded units that were available in the US.
## November 2023: shop.norvi.lk does now ship to the US, and the Germany based minipc.de and www.cartft.com resellers also ships to the US, ordered from both stores.
## December 2023: received a NORVI-ENET-AE06-R from Norvi CarTFT store, still waiting for unit from Norvi store.
##
## ADS1115 is documented as present in all units, but is absent in my SC-EN-I6-RO4, per Norvi the SensOper documentation is incorrect and the dedicated ADC is only present in analog input units.
## DS3231 is documented as present in the SC-EN-I6-RO4, but is missing in my April 2023 unit, per Norvi support the early Ethernet units did not include a RTC, current units should include the RTC.
##
## GPIO pins for inputs are incorrectly documented in SensOper docs, use the Norvi docs instead.
##
## April 2023 SC-EN-I6-RO4 ADC measured values for button presses are very different to theoretical values calculated from the resistor network.
## The ESP32 specs for 11dB attenuation calls for an input voltage range of 150mV to 2450mV, but the resistor network range goes to 2.71V (theoretical), above the usable range of the ESP32.
## The measured values vary based on the power source being USB or external power, and varies as the DC input is ranged from 12V to 24V.
## I did not attempt to reverse engineer the design from the PCB traces, but my conclusion is that the resistor network or ADC differential inputs are somehow referenced to actual input voltage.
## Using 11dB attenuation, 24VDC power source, moving window average:
## No button: ~0.9V - ~1.3V, very unstable, after a week of running the value drifted to ~2.3V
## Up: ~1.9V - ~2.0V, more stable than no button
## Down: ~2.3V - ~2.4V, more stable than no button
## Enter: ~2.9V, very stable
## SensOper support confirmed my observations in their own testing, but states that the USB input should only be used for programming, that raw ADC values should be used, and that the problem is with the ESP32 and not their design.
##
## WiFi is very unstable when running on 24VDC from my programmable linear bench PSU, but when running from USB or a dedicated switched mode 24VDC PSU WiFi works fine.
## Could be a problem with my bench PSU, that has never affected other micros, or an issue with power regulation on the device.
##
## My December 2023 IIOT-AE06-R the ADC values are stable and usable, and WiFi is stable, I am assuming my April 2023 SC-EN-I6-RO4 is faulty.
## Waiting on SensOper to send a replacement SC-EN-I6-RO4 with a DS3231.

# ESPHome support:
## DS3231 not yet supported, use DS1307 for RTC only
## https://github.com/esphome/feature-requests/issues/515
##
## WS5500 SPI based Ethernet not yet supported
## https://github.com/esphome/esphome/pull/4424
##
## microSD card not yet supported
## https://github.com/esphome/feature-requests/issues/513

# https://esphome.io/components/esphome
esphome:
  name: ${device_name}
  comment: ${device_comment}
  on_boot:
    then:
      # Read the RTC time on system boot
      ds1307.read_time:

# https://esphome.io/components/esp32
esp32:
  # Vanilla ESP32-WROOM32
  board: esp32dev

# https://esphome.io/guides/configuration-types.html#local-packages
packages:
  common: !include common-no-time.yaml
  memory_sensor:  !include esp32-memory-sensor.yaml

# https://esphome.io/components/i2c
i2c:
  sda: GPIO16
  scl: GPIO17
  scan: true
  # Increase speed to prevent component took a long time errors
  # https://github.com/esphome/issues/issues/4717#issuecomment-1643391691
  frequency: 400kHz

# Use expansion slot Pin6 GPIO15 for 1-wire protocol
# TODO: Investigate why we get occasional scratchpad errors when using the default dallas component?
# https://github.com/esphome/issues/issues?q=is%3Aissue+is%3Aopen+Scratch+pad+checksum+invalid
# Use the alternative dallasng component instead of the built in dallas component
# https://github.com/nrandell/dallasng
# https://github.com/pstolarz/OneWireNg
external_components:
  - source: github://nrandell/dallasng

# https://esphome.io/components/sensor/dallas.html
dallasng:
  # TODO: How to add ignore_strapping_warning: true
  # https://github.com/esphome/feature-requests/issues/2499
  # WARNING GPIO15 is a strapping PIN and should only be used for I/O with care.
  - pin: GPIO15
    update_interval: 5s

# https://esphome.io/components/time
time:
  # DS3231 additional sensors are not supported but is compatible with DS1307 RTC
  # https://esphome.io/components/time/ds1307
  - platform: ds1307
    id: ds1307_time
    address: 0x68
    # Use HA for time sync
    update_interval: never
  # https://esphome.io/components/time/homeassistant
  - platform: homeassistant
    id: homeassistant_time
    # Update RTC on time sync
    on_time_sync:
      then:
        ds1307.write_time:

# https://esphome.io/components/display/index.html
font:
  - file:
      type: gfonts
      family: Open+Sans
    id: fonnt # font as id is reserved
    size: 14

# https://esphome.io/components/display/ssd1306.html
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    # TODO: How to get font height in pixels from font point size?
    # TextAlign: TOP_LEFT, TOP_RIGHT, BASELINE_LEFT
    # print (int x, int y, BaseFont *font, Color color, TextAlign align, const char *text)
    # printf (int x, int y, BaseFont *font, TextAlign align, const char *format,...)
    # https://strftime.org/
    # strftime (int x, int y, BaseFont *font, Color color, TextAlign align, const char *format, ESPTime time)
    lambda: |-
      const auto color = Color(255, 255, 255);
      const auto font = id(fonnt);
      const int fontHeight = 24;
      int line = 0;
      const auto time = id(homeassistant_time).now();
      const auto ip = id(wifi_ip).state.c_str();
      const auto tmp = isnan(id(temp).state) ? 0.0 : id(temp).state;
      // const auto adc = id(adc_buttons).state;
      it.printf(0, line, font, color, TextAlign::TOP_LEFT, "IP: %s", ip);
      line += fontHeight;
      it.printf(0, line, font, color, TextAlign::TOP_LEFT, "Temp: %.2fÂ°C", tmp);
      // it.printf(0, line, font, color, TextAlign::TOP_LEFT, "ADC: %.2fV", adc);
      line += fontHeight;
      it.strftime(0, line, font, color, TextAlign::TOP_LEFT, "Time: %H:%M:%S", time);
      line += fontHeight;

# https://esphome.io/components/sensor/
sensor:

  # https://esphome.io/components/sensor/adc.html
  - platform: adc
    pin: GPIO36
    name: ${device_name}_adc_buttons
    id: adc_buttons
    # Use raw values, we only need ranges not absolute values, but it is not portable between chip variants
    raw: true
    # 11dB is required for the 2.7V max input, but theoretical max for chip is 2.4V
    attenuation: 11dB 
    # Update fast enough to make button presses responsive
    update_interval: 100ms # effectively multiplied by filter send_every so 300ms
    # Average values
    # https://esphome.io/components/sensor/index.html#sliding-window-moving-average
    filters:
      - filter_out: nan
      - sliding_window_moving_average:
          window_size: 3
          send_every: 3
          send_first_at: 3
    # Used internally for switch templates only, do not report to HA
    internal: true

  # Dallas sensors need to be handled in the device config
  # https://esphome.io/components/sensor/dallas.html
  # - platform: dallas
  #   address: 0xC7012026F75E6028
  #   name: ${device_name}_temp
  #   id: temp

# https://esphome.io/components/switch/index.html
switch:

  # https://esphome.io/components/switch/gpio.html
  - platform: gpio
    name: ${device_name}_relay_0
    id: relay_0
    pin: 
      number: GPIO2
      ignore_strapping_warning: true
    restore_mode: ALWAYS_OFF
  - platform: gpio
    name: ${device_name}_relay_1
    id: relay_1
    pin: GPIO4
    restore_mode: ALWAYS_OFF
  - platform: gpio
    name: ${device_name}_relay_2
    id: relay_2
    pin: 
      number: GPIO12
      ignore_strapping_warning: true
    restore_mode: ALWAYS_OFF
  - platform: gpio
    name: ${device_name}_relay_3
    id: relay_3
    pin: GPIO13
    restore_mode: ALWAYS_OFF

# https://esphome.io/components/binary_sensor/
binary_sensor:

  # https://esphome.io/components/binary_sensor/template.html
  # Convert ADC input to button presses
  # Resistor network: 3.3V, S3 10K, S2 33K, S1 67K, 47K GND
  # Theoretical values for single button presses in V:
  # None : 0
  # Up   : 1.361V
  # Down : 1.939V
  # Enter: 2.721V
  # Measured values on Norvi IIOT-AE06-R using 11dB:
  # None : ~0.075V
  # Up:    ~1.35V
  # Down:  ~1.94V
  # Enter: ~2.71V
  # Measured values on Norvi IIOT-AE06-R using 11dB and raw:
  # None : ~0
  # Up:    ~1475
  # Down:  ~2195
  # Enter: ~3195
  # Matrix raw values:
  #         < 1300: 0 0 0
  # >= 1300 < 2000: 1 0 0
  # >= 2000 < 2450: 0 1 0
  # >= 2450 < 2950: 1 1 0
  # >= 2950 < 3280: 0 0 1
  # >= 3280 < 3380: 1 0 1
  # >= 3380 < 3460: 0 1 1
  # >= 3460 < 3800: 1 1 1
  - platform: template
    name: ${device_name}_button_up
    id: button_up
    lambda: |-
      const auto adc = id(adc_buttons).state;
      return (adc >= 1300.0 && adc < 2000.0) ||
             (adc >= 2450.0 && adc < 2950.0) ||
             (adc >= 3280.0 && adc < 3380.0) ||
             (adc >= 3460.0 && adc < 3800.0);
  - platform: template
    name: ${device_name}_button_down
    id: button_down
    lambda: |-
      const auto adc = id(adc_buttons).state;
      return (adc >= 2000.0 && adc < 2450.0) ||
             (adc >= 2450.0 && adc < 2950.0) ||
             (adc >= 3380.0 && adc < 3460.0) ||
             (adc >= 3460.0 && adc < 3800.0);
  - platform: template
    name: ${device_name}_button_enter
    id: button_enter
    lambda: |-
      const auto adc = id(adc_buttons).state;
      return (adc >= 2950.0 && adc < 3280.0) ||
             (adc >= 3280.0 && adc < 3380.0) ||
             (adc >= 3380.0 && adc < 3460.0) ||
             (adc >= 3460.0 && adc < 3800.0);

  # Inputs need to be handled in the device config as gpio, pulse counters, etc.
  #
  # https://esphome.io/components/binary_sensor/gpio.html
  # - platform: gpio
  #   name: ${device_name}_input_0
  #   id: input_0
  #   pin: 
  #     number: GPIO21
  #     inverted: true
  #
  # https://esphome.io/components/sensor/pulse_counter.html
  # - platform: pulse_counter
  #   pin:
  #     number: GPIO21
  #     inverted: true
